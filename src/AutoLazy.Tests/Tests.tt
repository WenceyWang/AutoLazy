<#@ template debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ Assembly Name="System.Core.dll" #>
<#@ Assembly Name="System.Xml.dll" #>
<#@ Assembly Name="System.Xml.Linq.dll" #>
<#@ Assembly Name="System.Windows.Forms.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #> 
<#
    var initial = new [] { new { } };
	var q = from v1 in initial
			from Static in new [] { true, false }
			from item in new [] { new { Type = typeof(Guid), Expression = "Guid.NewGuid()" }, new { Type = typeof(string), Expression = "Guid.NewGuid().ToString()" } }
			let Type = item.Type
			let Expression = item.Expression
			from Try in new [] { false, true }
			from GenericType in new [] { false, true }
			from GenericMethod in new [] { false, true }
			select new { Static, Type, Expression, Try, GenericType, GenericMethod };
	var fixtures = q.ToArray();
#>
using System;
using NUnit.Framework;

namespace AutoLazy.Tests
{
<# foreach (var fixture in fixtures)
   {
       var classPrefix = string.Format(
           "{0}{1}{2}{3}{4}",
           fixture.Static ? "Static" : "Instance",
           fixture.Type.Name,
           fixture.Try ? "WithTry" : "",
           fixture.GenericType ? "GenericType" : "",
           fixture.GenericMethod ? "GenericMethod" : "");
       var type = fixture.Type.Name;
       var expression = fixture.Expression;
       var withTry = fixture.Try;
       var genericType = fixture.GenericType;
       var concretePrefix = classPrefix;
       if (fixture.GenericType) concretePrefix += $"<{fixture.Type}>";
#>
    public class Mock<#=classPrefix#><#=genericType ? "<T>" : ""#>
    {
        public static int GetCount;
        public static int PropCount;

        [Lazy]
        public static <#=type#> Get<#=type#>()
        {
<#  if (withTry)
    {
#>
            try {
<#
    }
#>
            ++GetCount;
            return <#=expression#>;
<#  if (withTry)
    {
#>
            } catch (Exception e) {
                throw new Exception("foo", e);
            } finally {
                Console.WriteLine("Finally!");
            }
<#  }#>
        }

        [Lazy]
        public static <#=type#> <#=type#>Prop
        {
            get
            {
<#  if (withTry)
    {
#>
            try {
<#
    }
#>
                ++PropCount;
                return <#=expression#>;
<#  if (withTry)
    {
#>
            } catch (Exception e) {
                throw new Exception("foo", e);
            } finally {
                Console.WriteLine("Finally!");
            }
<#  }#>
            }
        }

    }

    [TestFixture]
    public class <#=classPrefix#>Tests
    {
        [Test]
        public void Get<#=type#>_should_be_lazy()
        {
            Assert.AreEqual(0, Mock<#=concretePrefix#>.GetCount);
            var first = Mock<#=concretePrefix#>.Get<#=type#>();
            Assert.AreEqual(1, Mock<#=concretePrefix#>.GetCount);
            var second = Mock<#=concretePrefix#>.Get<#=type#>();
            Assert.AreEqual(1, Mock<#=concretePrefix#>.GetCount);
            Assert.AreEqual(first, second);
        }

        [Test]
        public void <#=type#>Prop_should_be_lazy()
        {
            Assert.AreEqual(0, Mock<#=concretePrefix#>.PropCount);
            var first = Mock<#=concretePrefix#>.<#=type#>Prop;
            Assert.AreEqual(1, Mock<#=concretePrefix#>.PropCount);
            var second = Mock<#=concretePrefix#>.<#=type#>Prop;
            Assert.AreEqual(1, Mock<#=concretePrefix#>.PropCount);
            Assert.AreEqual(first, second);
        }
    }

<# } #>
}